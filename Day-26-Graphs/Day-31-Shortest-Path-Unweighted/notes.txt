DAY 31 – Shortest Path in Unweighted Graph (BFS)

-----------------------------------------
CORE IDEA
-----------------------------------------
In an unweighted graph, every edge has weight = 1.

BFS explores the graph level by level.
The first time we visit a node, we have reached it
through the shortest possible path.

Therefore:
BFS = Shortest Path (only for unweighted graphs)


-----------------------------------------
ALGORITHM STEPS
-----------------------------------------
1. Build adjacency list.
2. Initialize distance array with -1.
3. Set dist[source] = 0.
4. Push source into queue.
5. While queue not empty:
    - Pop node
    - For each neighbor:
        If not visited (dist == -1):
            dist[neighbor] = dist[node] + 1
            push into queue
6. Return distance array.


-----------------------------------------
WHY DFS DOES NOT WORK?
-----------------------------------------
DFS goes deep first.
It may reach a node through a longer path before
discovering a shorter one.

So DFS cannot guarantee shortest path.


-----------------------------------------
DRY RUN EXAMPLE
-----------------------------------------
n = 6
edges:
0-1
0-2
1-3
2-4
4-5

Source = 0

Level 0: 0 → dist[0] = 0
Level 1: 1,2 → dist = 1
Level 2: 3,4 → dist = 2
Level 3: 5 → dist = 3

Final distance array:
[0,1,1,2,2,3]


-----------------------------------------
EDGE CASES
-----------------------------------------
1. Disconnected graph
   → Some nodes remain -1

2. Single node graph
   → Output = [0]

3. No edges
   → Only source = 0, rest = -1

4. Directed graph
   → Remove reverse edge while building graph


-----------------------------------------
TIME & SPACE
-----------------------------------------
Time: O(V + E)
Space: O(V)


-----------------------------------------
INTERVIEW QUESTIONS
-----------------------------------------
Q1: When does BFS give shortest path?
    → Only in unweighted graph.

Q2: What if graph has weig
