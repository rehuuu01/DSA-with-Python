==============================
DAY 39 ‚Äì 0/1 KNAPSACK NOTES
==============================

1Ô∏è‚É£ Pattern Recognition

Knapsack problems usually involve:
- Capacity constraint
- Maximizing value / minimizing cost
- Choose or skip items

Signal words:
- ‚ÄúAt most once‚Äù
- ‚ÄúPick or not pick‚Äù
- ‚ÄúMaximum profit/value‚Äù

------------------------------------------------

2Ô∏è‚É£ Recurrence Relation

f(n, W) =
    0                                  if n == 0 or W == 0
    f(n-1, W)                          if weight[n-1] > W
    max(
        value[n-1] + f(n-1, W - weight[n-1]),
        f(n-1, W)
    )                                  otherwise

------------------------------------------------

3Ô∏è‚É£ Why Overlapping Subproblems?

Same (n, W) state gets recomputed multiple times.
Hence we store results in dp[n][W].

Total states = n * W
Therefore complexity becomes O(nW).

------------------------------------------------

4Ô∏è‚É£ Why Backward Loop in Space Optimization?

In 1D DP:

dp[w] = max(dp[w], value[i] + dp[w - weight[i]])

If we iterate forward:
We may reuse updated values from same row
‚Üí That becomes Unbounded Knapsack (WRONG)

So we iterate backwards:
for w in range(W, weight[i]-1, -1)

This preserves previous row values.

------------------------------------------------

5Ô∏è‚É£ Difference from Unbounded Knapsack

0/1 Knapsack:
- Each item only once
- Iterate capacity backward

Unbounded Knapsack:
- Unlimited times
- Iterate capacity forward

------------------------------------------------

6Ô∏è‚É£ Interview Tip

Always explain:
- State definition
- Transition
- Base case
- Why time = O(nW)

Most candidates only write code.
Strong candidates explain DP logic clearly.

------------------------------------------------

Day 39 Completed ‚úî
Knapsack pattern unlocked üî•